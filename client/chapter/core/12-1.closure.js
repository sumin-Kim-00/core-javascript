/* -------------------------------------------------------------------------- */
/* 클로저(Closures)                                                             */
/* -------------------------------------------------------------------------- */


// 클로저 (closure) 란?
// - JavaScript의 매우 강력한 특성으로 독립적인 변수를 참조하는 함수를 말합니다.
//   즉, 클로저에 정의된 함수는 그것이 작성된 환경을 '기억'합니다.

// 사용하는 이유 - 전역의 오염을 막기 위해


function first() {
  let x = 10;

  return function () {
    let y = 30;
    return x + y;  // 이게 잘 동작하는 이유는 스코프 체이닝, x를 찾아가기 때문(Outer Environment Reference)
            // Outer Environment Reference - 이 친구가 부모를 계속 보고 있음(first 함수를 계속 보고 있음)
            // 바깥 환경을 지켜보고있다가 본인에게 없는 것을 부모에게서 찾는다 !
  }

  // return second;  // JS는 함수=값으로 인식하므로 first 함수를 실행하면 second 함수 전체가 튀어나옴
                  // second 함수를 실행하려면 first()() 하면 됨(first()가  secoun함수 그 잡채이기 때문)
}

const value = first();   // 이건 second 함수 그 자체(본문)를 value에 줌 -> value() 이렇게 할 수 있음


// return을 객체로 하면 이걸 변수로 받으면 user는 객체가 됨
// const user = first();





// let count = 0;  // 만약 밑에 count를 재정의 하면 얘건 number건 쓸모 없게 됨(전역이 오염됨)
function number() {
  let count = 0;    // 이제 count는 함수 안에 있으므로 외부에서 찾을 수 없음

  return () => ++count;   // count 값 찾을 수 있음

  // return inner;  // 밖에 내보내는 애가 어떤 이름 인지는 1도 필요 없음 --> 무명함수로 바꿈
}

const counter = number();  // counter는 이제부터 함수의 능력(inner)을 사용할 수 있는 애가 됨( counter() 가능 )
  // 얘가 게속 할당되어 있으니까(연결이 되어 있으니까) 가비지 컬렉터가 들어오지 못하고 나감
  // 이렇게 할당한게 closure !!!

// 마치 number() 함수를 다른 애들이 접근하지 못하게 꽉 묶어놓은 것과 같음( CLOSURE - 폐쇄 ) !!!







// 모든 함수에는 실행 컨텍스트가 있습니다. 실행 컨텍스트는 해당 함수 내의 변수와 
// 해당 부모 환경에 대한 참조를 의미하는 환경으로 구성됩니다. 상위 환경에 대한 참조는 
// 내부 함수가 작성된 범위 외부 또는 내부에서 호출되는지 여부에 관계없이 상위 범위의 
// 모든 변수를 모든 내부 함수에 사용할 수 있게 합니다.
//
// 따라서 함수가 사실상 환경(해당 환경에 정의된 변수)에 대한 참조를 가지고 있기 때문에 
// 함수가 이 환경(또는 영역(scope))을 "기억"하는 것처럼 보입니다!
//
// 모든 실행 컨텍스트에는 어휘 환경(Lexical Environment)이 있습니다. 
// 이 어휘 환경은 식별자 바인딩(즉, 변수 및 관련 값)을 보유하고 있으며 
// 외부 환경에 대한 참조도 가지고 있습니다.
// 
// 각 환경이 접근 할 수 있는 일련의 식별자를 "범위(Scope)"라고 합니다. 
// 이러한 범위를 "스코프 체인(Scope Chain)"을 통해 계층적 환경 체인에 
// 중첩 할 수 있습니다.






// 어느 시점이든 하나의 실행 컨텍스트만 실행 될 수 있습니다.
// 이것이 JavaScript가 "단일 스레드"인 이유입니다.
// 
// 즉, 한 번에 하나의 명령만 처리 할 수 있습니다. 일반적으로 
// 브라우저는 "스택(Stack)"을 사용하여 이 실행 컨텍스트를 유지 관리합니다. 
// 스택은 LIFO(Last In First Out) 데이터 구조입니다. 

//
// 스택에 푸시(push) 한 마지막 것이 가장 먼저 꺼내집니다. 스택의 
// 맨 위에 요소만 삽입하거나 삭제할 수 있기 때문입니다. 현재 또는 
// "실행 중인" 실행 컨텍스트는 항상 스택의 맨 위에 있는 항목입니다. 
//
// 실행 중인 실행 컨텍스트의 코드가 완전히 평가되면 최상위 항목이 
// 팝(pop) 된 다음 실행 항목이 실행 컨텍스트를 실행하는 것으로 
// 간주됩니다.
//
// 또한 실행 컨텍스트가 실행되고 있다고 해서 다른 실행 컨텍스트를 
// 실행하기 전에 실행이 완료되어야한다는 것을 의미하지는 않습니다. 
// 실행 중인 실행 컨텍스트가 일시 중단되고 다른 실행 컨텍스트가 
// 실행 중인 실행 컨텍스트가되는 경우가 있습니다. 
// 
// 일시중단 된 실행 컨텍스트는 나중에 중단 된 부분을 선택합니다. 
// 한 실행 컨텍스트가 이와 같이 다른 컨텍스트로 대체 될 때마다 
// 새 실행 컨텍스트가 만들어져 스택에 푸시되고 현재 실행 컨텍스트가 됩니다.

// [ 실행 컨텍스트 N + 3  ] ⬅︎ 현재 실행 컨텍스트 
// [ 실행 컨텍스트 N + 2  ] 
// [ 실행 컨텍스트 N + 1  ] 
// [ 실행 컨텍스트 N      ] 
// [ 실행 컨텍스트        ] // 글로벌